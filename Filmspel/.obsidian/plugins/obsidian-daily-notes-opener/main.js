/* THIS IS A GENERATED/BUNDLED FILE BY ESBUILD */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings2() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format2, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings = calendarSettings || {};
        return {
          format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join2(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    function ensureFolderExists(path) {
      return __async(this, null, function* () {
        const dirs = path.replace(/\\/g, "/").split("/");
        dirs.pop();
        if (dirs.length) {
          const dir = join2(...dirs);
          if (!window.app.vault.getAbstractFileByPath(dir)) {
            yield window.app.vault.createFolder(dir);
          }
        }
      });
    }
    function getNotePath2(directory, filename) {
      return __async(this, null, function* () {
        if (!filename.endsWith(".md")) {
          filename += ".md";
        }
        const path = obsidian.normalizePath(join2(directory, filename));
        yield ensureFolderExists(path);
        return path;
      });
    }
    function getTemplateInfo(template) {
      return __async(this, null, function* () {
        const { metadataCache, vault } = window.app;
        const templatePath = obsidian.normalizePath(template);
        if (templatePath === "/") {
          return Promise.resolve(["", null]);
        }
        try {
          const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
          const contents = yield vault.cachedRead(templateFile);
          const IFoldInfo = window.app.foldManager.load(templateFile);
          return [contents, IFoldInfo];
        } catch (err) {
          console.error(`Failed to read the daily note template '${templatePath}'`, err);
          new obsidian.Notice("Failed to read the daily note template");
          return ["", null];
        }
      });
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format) {
      return format.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings2,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(filename, format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    function createDailyNote2(date) {
      return __async(this, null, function* () {
        const app = window.app;
        const { vault } = app;
        const moment = window.moment;
        const { template, format, folder } = getDailyNoteSettings2();
        const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
        const filename = date.format(format);
        const normalizedPath = yield getNotePath2(folder, filename);
        try {
          const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = moment();
            const currentDate = date.clone().set({
              hour: now.get("hour"),
              minute: now.get("minute"),
              second: now.get("second")
            });
            if (calc) {
              currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
              return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
          }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
          app.foldManager.save(createdFile, IFoldInfo);
          return createdFile;
        } catch (err) {
          console.error(`Failed to create file: '${normalizedPath}'`, err);
          new obsidian.Notice("Unable to create new file.");
        }
      });
    }
    function getDailyNote(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings2();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment } = window;
      let weekStart = moment.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    function createWeeklyNote(date) {
      return __async(this, null, function* () {
        const { vault } = window.app;
        const { template, format, folder } = getWeeklyNoteSettings();
        const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
        const filename = date.format(format);
        const normalizedPath = yield getNotePath2(folder, filename);
        try {
          const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
              hour: now.get("hour"),
              minute: now.get("minute"),
              second: now.get("second")
            });
            if (calc) {
              currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
              return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
          }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
            const day = getDayOfWeekNumericalValue(dayOfWeek);
            return date.weekday(day).format(momentFormat.trim());
          }));
          window.app.foldManager.save(createdFile, IFoldInfo);
          return createdFile;
        } catch (err) {
          console.error(`Failed to create file: '${normalizedPath}'`, err);
          new obsidian.Notice("Unable to create new file.");
        }
      });
    }
    function getWeeklyNote(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    function createMonthlyNote(date) {
      return __async(this, null, function* () {
        const { vault } = window.app;
        const { template, format, folder } = getMonthlyNoteSettings();
        const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
        const filename = date.format(format);
        const normalizedPath = yield getNotePath2(folder, filename);
        try {
          const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
              hour: now.get("hour"),
              minute: now.get("minute"),
              second: now.get("second")
            });
            if (calc) {
              currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
              return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
          }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
          window.app.foldManager.save(createdFile, IFoldInfo);
          return createdFile;
        } catch (err) {
          console.error(`Failed to create file: '${normalizedPath}'`, err);
          new obsidian.Notice("Unable to create new file.");
        }
      });
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    function createQuarterlyNote(date) {
      return __async(this, null, function* () {
        const { vault } = window.app;
        const { template, format, folder } = getQuarterlyNoteSettings();
        const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
        const filename = date.format(format);
        const normalizedPath = yield getNotePath2(folder, filename);
        try {
          const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
              hour: now.get("hour"),
              minute: now.get("minute"),
              second: now.get("second")
            });
            if (calc) {
              currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
              return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
          }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
          window.app.foldManager.save(createdFile, IFoldInfo);
          return createdFile;
        } catch (err) {
          console.error(`Failed to create file: '${normalizedPath}'`, err);
          new obsidian.Notice("Unable to create new file.");
        }
      });
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    function createYearlyNote(date) {
      return __async(this, null, function* () {
        const { vault } = window.app;
        const { template, format, folder } = getYearlyNoteSettings();
        const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
        const filename = date.format(format);
        const normalizedPath = yield getNotePath2(folder, filename);
        try {
          const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
              hour: now.get("hour"),
              minute: now.get("minute"),
              second: now.get("second")
            });
            if (calc) {
              currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
              return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
          }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
          window.app.foldManager.save(createdFile, IFoldInfo);
          return createdFile;
        } catch (err) {
          console.error(`Failed to create file: '${normalizedPath}'`, err);
          new obsidian.Notice("Unable to create new file.");
        }
      });
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings2(granularity) {
      const getSettings = {
        day: getDailyNoteSettings2,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote2(granularity, date) {
      const createFn = {
        day: createDailyNote2,
        month: createMonthlyNote,
        week: createWeeklyNote
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote2;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote2;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote;
    exports.getDailyNoteSettings = getDailyNoteSettings2;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings2;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// package.json
var require_package = __commonJS({
  "package.json"(exports, module2) {
    module2.exports = {
      name: "obsidian-daily-notes-opener",
      version: "2.0.2",
      description: "Easily open daily/periodic notes in new pane, and much more!",
      main: "main.js",
      scripts: {
        dev: "node esbuild.config.mjs",
        build: "tsc -noEmit -skipLibCheck && BUILD_ENV=production node esbuild.config.mjs && cp manifest.json build",
        version: "node version-bump.mjs && git add manifest.json versions.json",
        release: "yarn build && gh release create ${npm_package_version} build/*"
      },
      keywords: [],
      author: "Reorx",
      license: "MIT",
      devDependencies: {
        "@types/node": "^16.11.6",
        "@typescript-eslint/eslint-plugin": "^5.2.0",
        "@typescript-eslint/parser": "^5.2.0",
        "builtin-modules": "^3.2.0",
        esbuild: "0.13.12",
        eslint: "^8.12.0",
        obsidian: "^0.13.26",
        tslib: "2.3.1",
        typescript: "4.4.4"
      },
      dependencies: {
        dot: "^2.0.0-beta.1",
        "obsidian-daily-notes-interface": "^0.9.4"
      }
    };
  }
});

// src/main.ts
__export(exports, {
  default: () => DailyNotesNewPanePlugin
});
var import_obsidian3 = __toModule(require("obsidian"));
var import_obsidian_daily_notes_interface = __toModule(require_main());

// src/utils.ts
var import_obsidian = __toModule(require("obsidian"));
var DEBUG = false;
function debugLog(...args) {
  if (DEBUG) {
    console.log(new Date().toISOString().slice(11, 23), ...args);
  }
}
function getContainerElfromLeaf(leaf) {
  const extendedLeaf = leaf;
  return extendedLeaf.containerEl;
}
function renderTemplate(tmpl, data) {
  for (const key in data) {
    tmpl = tmpl.replace(new RegExp(`{{${key}}}`, "g"), data[key]);
  }
  return tmpl;
}
var FileViewMode;
(function(FileViewMode2) {
  FileViewMode2["source"] = "source";
  FileViewMode2["preview"] = "preview";
  FileViewMode2["default"] = "default";
})(FileViewMode || (FileViewMode = {}));
var NewPaneDirection;
(function(NewPaneDirection2) {
  NewPaneDirection2["vertical"] = "vertical";
  NewPaneDirection2["horizontal"] = "horizontal";
})(NewPaneDirection || (NewPaneDirection = {}));
function openFile(app, file, optional) {
  return __async(this, null, function* () {
    let leaf;
    if ((optional == null ? void 0 : optional.openInNewPane) && (optional == null ? void 0 : optional.direction)) {
      leaf = app.workspace.splitActiveLeaf(optional.direction);
    } else {
      leaf = app.workspace.getUnpinnedLeaf();
    }
    yield leaf.openFile(file);
    if ((optional == null ? void 0 : optional.mode) || (optional == null ? void 0 : optional.focus)) {
      const viewState = leaf.getViewState();
      yield leaf.setViewState(__spreadProps(__spreadValues({}, viewState), {
        state: optional.mode && optional.mode !== "default" ? __spreadProps(__spreadValues({}, viewState.state), {
          mode: optional.mode
        }) : viewState.state,
        popstate: true
      }), { focus: optional == null ? void 0 : optional.focus });
    }
    return leaf;
  });
}

// src/appendline.ts
var appendLine = (app, view, targetHeader, linePrefix) => {
  const editor = view.editor;
  editor.focus();
  let positionFound = false;
  const sections = app.metadataCache.getFileCache(view.file).headings;
  debugLog("sections", sections);
  if (sections && targetHeader) {
    const targetSection = sections.find((eachSection) => eachSection.heading === targetHeader);
    if (targetSection !== void 0) {
      debugLog("targetSection", targetSection);
      const nextSection = sections.find((eachSection) => eachSection.position.start.line > targetSection.position.start.line && eachSection.level <= targetSection.level);
      debugLog(nextSection);
      if (nextSection !== void 0) {
        positionFound = true;
        appendInTargetSection(editor, linePrefix, targetSection, nextSection);
      } else {
        debugLog("No section follows the target section. Inserting the log item at the end of the target section.");
      }
    }
  }
  if (!positionFound) {
    debugLog("no position found, append to the bottom");
    editor.setCursor(editor.lastLine());
    editor.replaceSelection(linePrefix);
    editor.setCursor(editor.lastLine());
  }
};
function appendInTargetSection(editor, linePrefix, targetSection, nextSection) {
  if (editor.getLine(nextSection.position.start.line - 1) === editor.getLine(targetSection.position.start.line)) {
    editor.setCursor(nextSection.position.start.line - 1);
    editor.replaceSelection(linePrefix);
    editor.setCursor(nextSection.position.start.line);
  } else if (editor.getLine(nextSection.position.start.line - 1).length > 0) {
    debugLog("No blank lines found between the target section and the next section.");
    editor.setCursor(nextSection.position.start.line - 2);
    editor.replaceSelection(linePrefix);
    editor.setCursor(nextSection.position.start.line);
  } else {
    debugLog(`The line before the next section has 0 length. It is line number: ${nextSection.position.start.line - 1}`);
    let lastBlankLineFound = false;
    let noBlankLines = false;
    let lastLineBeforeLineBreakIteratorLineNumber = nextSection.position.start.line - 1;
    while (lastBlankLineFound == false) {
      if (lastLineBeforeLineBreakIteratorLineNumber == 0) {
        noBlankLines = true;
        lastBlankLineFound = true;
      } else {
        const blankLineFinderCurrentLine = editor.getLine(lastLineBeforeLineBreakIteratorLineNumber);
        if (blankLineFinderCurrentLine.toString() === "") {
          lastBlankLineFound = true;
          debugLog("found the last line");
        } else {
          lastLineBeforeLineBreakIteratorLineNumber = lastLineBeforeLineBreakIteratorLineNumber - 1;
        }
      }
    }
    if (noBlankLines) {
      debugLog("No blank lines found.");
      editor.setCursor(nextSection.position.start.line - 1);
      editor.replaceSelection(linePrefix);
      editor.setCursor(nextSection.position.start.line - 1);
    } else {
      debugLog(`Iterator stopped at line ${lastLineBeforeLineBreakIteratorLineNumber}, with text ${editor.getLine(lastLineBeforeLineBreakIteratorLineNumber)}`);
      editor.setCursor(lastLineBeforeLineBreakIteratorLineNumber - 1);
      editor.replaceSelection(linePrefix);
      editor.setCursor(lastLineBeforeLineBreakIteratorLineNumber);
    }
  }
}

// src/styles.ts
var periodicNoteTypes = ["day", "week"];
var periodicNoteClass = (type) => {
  return `periodic-note-${type}`;
};
var addTodayNoteClass = (leaf, type) => {
  const el = getContainerElfromLeaf(leaf);
  el.addClass(periodicNoteClass(type));
};
var removeTodayNoteClass = (leaf) => {
  const el = getContainerElfromLeaf(leaf);
  for (const type of periodicNoteTypes) {
    el.removeClass(periodicNoteClass(type));
  }
};
var periodicNoteStylesTmpl = `/* style for {{type}} type */
{{prefix}} .view-header,
{{prefix}} .view-header > .view-actions,
{{prefix}} .workspace-leaf-header,
{{prefix}}.workspace-leaf.mod-active .view-header,
.workspace-split.mod-root>{{prefix}}.workspace-leaf:first-of-type:last-of-type .view-header
{
	{{backgroundCss}}
}

{{prefix}} .markdown-source-view,
{{prefix}} .markdown-reading-view {
	{{backgroundCss}}
}

{{prefix}} .CodeMirror-gutter.CodeMirror-linenumbers,
{{prefix}} .CodeMirror-gutter.CodeMirror-foldgutter {
	{{backgroundCss}}
}
`;
var StyleManger = class {
  constructor() {
    this.styleTag = document.head.createEl("style");
    this.styleTag.id = "daily-notes-opener-style";
  }
  makePeriodicNoteStyles(type) {
    return renderTemplate(periodicNoteStylesTmpl, {
      type,
      prefix: `.periodic-note-${type}`,
      backgroundCss: `background-color: var(--dno-${type}-background) !important;`
    });
  }
  setStyle(types) {
    let text = "";
    for (const type of types) {
      text += this.makePeriodicNoteStyles(type);
    }
    this.styleTag.innerText = text.trim().replace(/[\r\n\s]+/g, " ");
  }
  cleanup() {
    this.styleTag.remove();
  }
};

// src/vault.ts
var import_obsidian2 = __toModule(require("obsidian"));
function join(...partSegments) {
  let parts = [];
  for (let i = 0, l = partSegments.length; i < l; i++) {
    parts = parts.concat(partSegments[i].split("/"));
  }
  const newParts = [];
  for (let i = 0, l = parts.length; i < l; i++) {
    const part = parts[i];
    if (!part || part === ".")
      continue;
    else
      newParts.push(part);
  }
  if (parts[0] === "")
    newParts.unshift("");
  return newParts.join("/");
}
function getNotePath(directory, filename) {
  if (!filename.endsWith(".md")) {
    filename += ".md";
  }
  return (0, import_obsidian2.normalizePath)(join(directory, filename));
}

// src/main.ts
var DEFAULT_SETTINGS = {
  endOfDayTime: "05:00",
  alwaysOpenNewPane: false,
  periodicNotes: {},
  appendLineTargetHeader: "Journal",
  appendLinePrefix: "- {{DATE:HH:mm}} "
};
for (const _type of periodicNoteTypes) {
  DEFAULT_SETTINGS.periodicNotes[_type] = {
    customizeBackground: true
  };
}
var getNowShifted = (settings) => {
  const splited = settings.endOfDayTime.split(":").map(Number);
  if (splited.length !== 2) {
    throw new Error("Invalid end of day time format");
  }
  const now = window.moment();
  const shifted = now.clone().subtract(splited[0], "hours").subtract(splited[1], "minutes");
  debugLog("now", now.format("HH:mm"), "shifted", shifted.format("HH:mm"));
  return shifted;
};
var getTodayNotePath = (settings, periodicSettings) => {
  const { folder } = periodicSettings;
  let { format } = periodicSettings;
  if (!format) {
    format = "yyyy-MM-DD";
  }
  const nowShifted = getNowShifted(settings);
  return [getNotePath(folder, nowShifted.format(format)), nowShifted];
};
var getTodayPeriodicNotePath = (settings, periodicSettings) => {
  const { folder, format } = periodicSettings;
  if (!format) {
    throw new Error("Periodic note format is not defined");
  }
  const nowShifted = getNowShifted(settings);
  return [getNotePath(folder, nowShifted.format(format)), nowShifted];
};
var openOrCreateInNewPane = (app, path, createFileFunc, mode) => __async(void 0, null, function* () {
  console.debug("openOrCreateInNewPane", path);
  let file = app.vault.getAbstractFileByPath(path);
  if (!(file instanceof import_obsidian3.TFile)) {
    debugLog("create today note:", path);
    file = yield createFileFunc();
  }
  yield openFile(app, file, {
    openInNewPane: true,
    direction: NewPaneDirection.vertical,
    focus: true,
    mode
  });
});
var dateTmplRegex = /{{DATE:(.+)}}/gm;
var replaceDateTmpl = (s, date) => {
  const m = dateTmplRegex.exec(s);
  if (!m)
    return s;
  return s.replace(m[0], date.format(m[1]));
};
var DailyNotesNewPanePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.cachedPeriodicNotes = {};
  }
  getPeriodicType(path) {
    for (const key in this.cachedPeriodicNotes) {
      if (this.cachedPeriodicNotes[key] === path) {
        return key;
      }
    }
  }
  getAppendLinePrefix() {
    const now = window.moment();
    let prefix = this.settings.appendLinePrefix;
    let newprefix = replaceDateTmpl(prefix, now);
    while (prefix !== newprefix) {
      prefix = newprefix;
      newprefix = replaceDateTmpl(prefix, now);
    }
    return "\n" + prefix;
  }
  onload() {
    return __async(this, null, function* () {
      const pkg = require_package();
      console.log(`Plugin loading: ${pkg.name} ${pkg.version}`);
      yield this.loadSettings();
      this.styleManager = new StyleManger();
      this.setStyle();
      this.addCommand({
        id: "open-todays-daily-note-in-new-pane",
        name: "Open today's daily note in new pane",
        callback: () => __async(this, null, function* () {
          yield this.openTodayNoteInNewPane();
        })
      });
      this.addRibbonIcon("calendar-with-checkmark", "Open today's daily note in new pane", () => __async(this, null, function* () {
        yield this.openTodayNoteInNewPane();
      }));
      const openDailyNoteAndAppendLine = () => __async(this, null, function* () {
        yield this.openTodayNoteInNewPane();
        debugLog("done openTodayNoteInNewPane");
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view) {
          return;
        }
        debugLog("call appendLine");
        appendLine(this.app, view, this.settings.appendLineTargetHeader, this.getAppendLinePrefix());
      });
      this.addCommand({
        id: "open-todays-daily-note-in-new-pane-append-line",
        name: "Open today's daily note in new pane and append line",
        callback: openDailyNoteAndAppendLine
      });
      if (DEBUG) {
        this.addRibbonIcon("calendar-with-checkmark", "Open today's daily note in new pane and append line", () => __async(this, null, function* () {
          openDailyNoteAndAppendLine();
        }));
      }
      this.addCommand({
        id: "open-todays-weekly-note-in-new-pane",
        name: "Open today's weekly note in new pane",
        callback: () => {
          this.openTodayPeriodicNoteInNewPane("week");
        }
      });
      if (DEBUG) {
        this.addRibbonIcon("calendar-with-checkmark", "Open today's weekly note in new pane", () => __async(this, null, function* () {
          yield this.openTodayPeriodicNoteInNewPane("week");
        }));
      }
      this.registerEvent(this.app.workspace.on("file-open", () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view) {
          return;
        }
        const { file } = view;
        const type = this.getPeriodicType(file.path);
        if (type) {
          addTodayNoteClass(view.leaf, type);
        } else {
          removeTodayNoteClass(view.leaf);
        }
      }));
      this.addSettingTab(new SettingPane(this.app, this));
    });
  }
  openTodayNoteInNewPane() {
    return __async(this, null, function* () {
      const periodicSettings = (0, import_obsidian_daily_notes_interface.getDailyNoteSettings)();
      const [todayNotePath, todayTime] = getTodayNotePath(this.settings, periodicSettings);
      this.cachedPeriodicNotes["day"] = todayNotePath;
      yield this.openInNewPane(todayNotePath, () => __async(this, null, function* () {
        return (0, import_obsidian_daily_notes_interface.createDailyNote)(todayTime);
      }), this.settings.alwaysOpenNewPane);
      debugLog("done openInNewPane");
    });
  }
  openTodayPeriodicNoteInNewPane(type) {
    return __async(this, null, function* () {
      const periodicSettings = (0, import_obsidian_daily_notes_interface.getPeriodicNoteSettings)(type);
      const [todayNotePath, todayTime] = getTodayPeriodicNotePath(this.settings, periodicSettings);
      this.cachedPeriodicNotes[type] = todayNotePath;
      return this.openInNewPane(todayNotePath, () => __async(this, null, function* () {
        return (0, import_obsidian_daily_notes_interface.createPeriodicNote)(type, todayTime);
      }), this.settings.alwaysOpenNewPane);
    });
  }
  openInNewPane(_0, _1) {
    return __async(this, arguments, function* (filePath, createFileFunc, forceNewPane = false, mode = FileViewMode.default) {
      if (forceNewPane) {
        yield openOrCreateInNewPane(this.app, filePath, createFileFunc, mode);
        return;
      }
      let todayNoteLeaf;
      this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
        const { file } = leaf.view;
        if (file.path === filePath) {
          todayNoteLeaf = leaf;
        } else {
          if (!this.getPeriodicType(file.path))
            removeTodayNoteClass(leaf);
        }
      });
      if (todayNoteLeaf) {
        yield todayNoteLeaf.setViewState(__spreadValues({}, todayNoteLeaf.getViewState()), { focus: true });
      } else {
        const { activeLeaf } = this.app.workspace;
        if (activeLeaf && activeLeaf.view && activeLeaf.view.getViewType() === "empty") {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          yield activeLeaf.openFile(file);
          return;
        }
        yield openOrCreateInNewPane(this.app, filePath, createFileFunc, mode);
      }
    });
  }
  onunload() {
    this.styleManager.cleanup();
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  setStyle() {
    const styledTypes = [];
    for (const type in this.settings.periodicNotes) {
      if (this.settings.periodicNotes[type].customizeBackground) {
        styledTypes.push(type);
      }
    }
    this.styleManager.setStyle(styledTypes);
  }
};
var SettingPane = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "General" });
    const nowYMD = window.moment().format("yyyy-MM-DD");
    const yesterdayYMD = window.moment().subtract(1, "day").format("yyyy-MM-DD");
    new import_obsidian3.Setting(containerEl).setName("End of day time").setDesc(`Determine today's date, if the value is 03:00 and the current datetime is ${nowYMD} 02:59, then the date for today is ${yesterdayYMD}`).addText((text) => text.setPlaceholder("HH:mm").setValue(this.plugin.settings.endOfDayTime).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.endOfDayTime = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Always open new pane").setDesc("Set true to always open new pane even if the daily note is already opened, otherwise the plugin will try to find the existing daily note and focus on it").addToggle((toggle) => toggle.setValue(this.plugin.settings.alwaysOpenNewPane).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.alwaysOpenNewPane = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Background colors").setDesc(`Daily notes new pane plugin adds support for colorizing today's periodic note, this functionality relies on another plugin called "Style Settings", please install and enable it so that you can adjust background colors for periodic notes`);
    containerEl.createEl("h2", { text: "Append line" });
    containerEl.createEl("div", {
      text: 'Control how "Append line" commands behave, note that this functionality is only avaliable for daily notes',
      attr: {
        style: `
					border: 1px solid #aaa;
					font-size: .8em;
					padding: 5px;
: 5px;				`
      }
    });
    new import_obsidian3.Setting(containerEl).setName("Append line prefix").setDesc('Set the prefix for lines added via "Append Line" command, only one template syntax is supported, which is "{{DATE:$FORMAT}}", the "$FORMAT" must be a Moment.js format, e.g. HH:mm').addText((text) => text.setPlaceholder("- HH:mm").setValue(this.plugin.settings.appendLinePrefix).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.appendLinePrefix = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Append line target header").setDesc("If set, the new line will be appended to the content of target header.").addText((text) => text.setPlaceholder("Journal").setValue(this.plugin.settings.appendLineTargetHeader).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.appendLineTargetHeader = value;
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Periodic notes" });
    containerEl.createEl("div", {
      text: `Daily notes new pane plugin adds support for colorizing today's periodic note, this functionality relies on another plugin called "Style Settings", please install and enable it so that you can adjust background colors for periodic notes`,
      attr: {
        style: `
					border: 1px solid #aaa;
					font-size: .8em;
					padding: 5px;
: 5px;				`
      }
    });
    containerEl.createEl("h3", { text: "Daily" });
    new import_obsidian3.Setting(containerEl).setName("Customize background color").setDesc("Enable customize background color for daily notes in Style Settings").addToggle((toggle) => toggle.setValue(this.plugin.settings.periodicNotes.day.customizeBackground).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.periodicNotes.day.customizeBackground = value;
      yield this.plugin.saveSettings();
      this.plugin.setStyle();
    })));
    containerEl.createEl("h3", { text: "Weekly" });
    new import_obsidian3.Setting(containerEl).setName("Customize background color").setDesc("Enable customize background color for weekly notes in Style Settings").addToggle((toggle) => toggle.setValue(this.plugin.settings.periodicNotes.week.customizeBackground).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.periodicNotes.week.customizeBackground = value;
      yield this.plugin.saveSettings();
      this.plugin.setStyle();
    })));
  }
};
